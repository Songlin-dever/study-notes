# Redis

## 数据结构

### String（字符串）

- 使用场景
  - 直接缓存整个对象的 JSON，命令例子： `SET user:1 '{"name":"xiaolin", "age":18}'`
  - 采用将 key 进行分离为 user:ID:属性，采用 MSET 存储，用 MGET 获取各属性值，命令例子： `MSET user:1:name xiaolin user:1:age 18 user:2:name xiaomei user:2:age 20`

### Hash（哈希）

- 使用场景
  - 存储对象，Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象
  - 购物车，以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素

### List（列表）

- 使用场景
  - 消息队列， LPUSH + RPOP

### Set（集合）

- 使用场景
  - 点赞，Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id
  - 共同关注，Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等，key 可以是用户id，value 则是已关注的公众号的id。
  - 抽奖活动，key为抽奖活动名，value为员工名称，如果允许重复中奖，可以使用 SRANDMEMBER 命令，如果不允许重复中奖，可以使用 SPOP 命令

### ZSet（有序集合）

- 使用场景
  - 排行榜
  - 电话和姓名排序，使用有序集合的 `ZRANGEBYLEX` 或 `ZREVRANGEBYLEX` 可以帮助我们实现电话号码或姓名的排序

### BitMap

使用场景
- 签到统计
- 判断用户登录态
- 连续签到用户总数

### HyperLogLog

- 使用场景
  - 百万级网页UV计数

### GEO

- 使用场景
  - 滴滴叫车

### Stream

- 使用场景
  - 消息队列

## 过期删除策略

- ### 定时删除

  - **在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。**
  - 优点：可以保证过期 key 会被尽快删除，也就是内存可以被尽快地释放。因此，定时删除对内存是最友好的。
  - 缺点：在过期 key 比较多的情况下，删除过期 key 可能会占用相当一部分 CPU 时间，在内存不紧张但 CPU 时间紧张的情况下，将 CPU 时间用于删除和当前任务无关的过期键上，无疑会对服务器的响应时间和吞吐量造成影响。所以，定时删除策略对 CPU 不友好。

- ### 惰性删除

  - **不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。**
  - 优点：因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。
  - 缺点：如果一个 key 已经过期，而这个 key 又仍然保留在数据库中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。

- ### 定期删除

  - **每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。**
  - 优点：通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。
  - 缺点：
    - 内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少
    - 难以确定删除操作执行的时长和频率。如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好；如果执行的太少，那又和惰性删除一样了，过期 key 占用的内存不会及时得到释放。

## 内存淘汰策略

- ### 不进行数据淘汰的策略

  - **noeviction**（Redis3.0之后，默认的内存淘汰策略） ：它表示当运行内存超过最大设置内存时，不淘汰任何数据，这时如果有新的数据写入，则会触发 OOM，但是如果没用数据写入的话，只是单纯的查询或者删除操作的话，还是可以正常工作。

- ### 进行数据淘汰的策略

  - #### 在设置了过期时间的数据中进行淘汰

    - **volatile-random**：随机淘汰设置了过期时间的任意键值
    - **volatile-ttl**：优先淘汰更早过期的键值
    - **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最久未使用的键值；
    - **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中，最少使用的键值；

  - #### 在所有数据范围内进行淘汰

    - **allkeys-random**：随机淘汰任意键值
    - **allkeys-lru**：淘汰整个键值中最久未使用的键值
    - **allkeys-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰整个键值中最少使用的键值

## 缓存

### 缓存雪崩

- 当**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**时，如果此时有大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃

#### 如果大量数据同时过期

- 均匀设置过期时间：**给数据的过期时间加上一个随机数**
- 互斥锁：
  - 当业务线程在处理用户请求时，**如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存**（从数据库读取数据，再将数据更新到 Redis 里），当缓存构建完成后，再释放锁。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
  - 实现互斥锁的时候，最好设置**超时时间**，不然第一个请求拿到了锁，然后这个请求发生了某种意外而一直阻塞，一直不释放锁，这时其他请求也一直拿不到锁，整个系统就会出现无响应的现象。
- 双key策略
  - 我们对缓存数据可以使用两个 key，一个是**主 key，会设置过期时间**，一个是**备 key，不会设置过期**，它们只是 key 不一样，但是 value 值是一样的，相当于给缓存数据做了个副本。
  - 当业务线程访问不到「主 key 」的缓存数据时，就直接返回「备 key 」的缓存数据，然后在更新缓存的时候，**同时更新「主 key 」和「备 key 」的数据。**
  - 优点：当主 key 过期了，有大量请求获取缓存数据的时候，直接返回备 key 的数据，这样可以快速响应请求。而不用因为 key 失效而导致大量请求被锁阻塞住（采用了互斥锁，仅一个请求来构建缓存），后续再通知后台线程，重新构建主 key 的数据。
- 后台更新缓存
  - 业务线程不再负责更新缓存，缓存也不设置有效期，而是**让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新**。
  - 事实上，缓存数据不设置有效期，并不是意味着数据一直能在内存里，因为**当系统内存紧张的时候，有些缓存数据会被“淘汰”**，而在缓存被“淘汰”到下一次后台定时更新缓存的这段时间内，业务线程读取缓存失败就返回空值，业务的视角就以为是数据丢失了，解决方法：
    - 后台线程不仅负责定时更新缓存，而且也负责**频繁地检测缓存是否有效**，检测到缓存失效了，原因可能是系统紧张而被淘汰的，于是就要马上从数据库读取数据，并更新到缓存。间隔最好是毫秒级的，但是总归是有个间隔时间，用户体验一般
    - 在业务线程发现缓存数据失效后（缓存数据被淘汰），**通过消息队列发送一条消息通知后台线程更新缓存**，后台线程收到消息后，在更新缓存前可以判断缓存是否存在，存在就不执行更新缓存操作；不存在就读取数据库数据，并将数据加载到缓存。这种方式相比第一种方式缓存的更新会更及时，用户体验也比较好。
  - 在业务刚上线的时候，我们最好提前把数据缓起来，而不是等待用户访问才来触发缓存构建，这就是所谓的**缓存预热**，后台更新缓存的机制刚好也适合干这个事情。

#### 如果Redis故障宕机

- 服务熔断或请求限流机制
  - 服务熔断：**暂停业务应用对缓存服务的访问，直接返回错误**，不用再继续访问数据库，从而降低对数据库的访问压力，保证数据库系统的正常运行，然后等到 Redis 恢复正常后，再允许业务应用访问缓存服务。
  - 请求限流：为了减少对业务的影响，**只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务**，等到 Redis 恢复正常并把缓存预热完后，再解除请求限流的机制。
- 构建 Redis 缓存高可靠集群
  - 服务熔断或请求限流机制是缓存雪崩发生后的应对方案，我们最好通过**主从节点的方式构建 Redis 缓存高可靠集群**。
  - 如果 Redis 缓存的主节点故障宕机，从节点可以切换成为主节点，继续提供缓存服务，避免了由于 Redis 故障宕机而导致的缓存雪崩问题。

### 缓存击穿

- 如果缓存中的**某个热点数据过期**了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮
- 应对缓存击穿可以采取前面说到两种方案：
  - 互斥锁：保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值。
  - 不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间

### 缓存穿透

- 用户访问的数据既不在缓存中，也不在数据库中，当这样的请求很多时，数据库压力骤增，即缓存穿透

- 缓存穿透发生的两种情况：

  - 业务误操作，缓存中的数据和数据库中的数据都被误删除了，所以导致缓存和数据库中都没有数据
  - 黑客恶意攻击，故意大量访问某些读取不存在数据的业务

- 应对方案：

  - 非法请求的限制

    - 在API入口处判断请求参数是否合理，是否含有非法值，请求字段是否存在，如果判断出是恶意请求就直接返回错误

  - 缓存空值或者默认值

    - 线上业务发现缓存穿透时，可以针对查询的数据在缓存中设置空值或默认值

  - 使用布隆过滤器快速判断数据是否存在，避免通过查询数据库来判断数据是否存在

    - 写入数据库时，用布隆过滤器做个标记，然后在请求到来时，业务线程确认缓存失效后，可以通过布隆过滤器来快速判断数据是否存在，如果不存在，就不用查询数据库

    - 布隆过滤器会通过 3 个操作完成标记：
      1. 使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值
      2. 将第一步得到的 N 个哈希值对位图数组的长度取模，得到每个哈希值在位图数组的对应位置。
      3. 将每个哈希值在位图数组的对应位置的值设置为 1

### 缓存一致

#### 问题描述

**由于引入了缓存，那么在数据更新时，不仅要更新数据库，而且要更新缓存，这两个更新操作存在前后的问题**：

- 先更新数据库，再更新缓存，问题：
  - 请求`A`把数据库更新为`1`，请求`B`把数据库更新为`2`，请求`B`把缓存更新为`2`，请求`A`把缓存更新为`1`；
- 先更新缓存，再更新数据库，问题：
  - 请求`A`把缓存更新为`1`，请求`B`把缓存更新为`2`，请求`B`把数据库更新为`2`，请求`A`把数据库更新为`1`；

#### 解决方案

- **先更新数据库，再删除缓存**，说明：因为缓存的写入通常远远快于数据库的写入，考虑这样一种情况：请求A缓存未命中，读取数据库20，请求B更新数据库为21，删除缓存，请求A将20写回缓存，此时数据库和缓存不一致。但是现实中一般请求A会在请求B删除缓存之前写回缓存

  （最好给缓存数据加上过期时间，这样如果删除缓存失败，那么旧数据过期后会重新读取数据库中的新数据）

- 假如删除缓存失败，有两种方法

  - **重试机制**，引入消息队列，把删除缓存要操作的数据放入消息队列中
    - 如果删除失败，重新读取数据继续删除，达到一定次数，向业务层发送报错信息
    - 如果成功，就把数据从消息队列中移除
  - **订阅 `MySQL binlog`，再操作缓存**
    - 更新数据库成功会产生一条变更日志记录在`binlog`里，通过订阅`binlog`日志拿到要操作的数据，然后再执行缓存删除
    - `Canal`模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 `Binlog` 给 `Canal`，`Canal` 解析 `Binlog` 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。

# Redis客户端

Spring-Data-Redis底层兼容`jedis`和`lettuce`



## Jedis

- 轻量，简洁，便于集成和改造
  - 以Redis命令作为方法名称，学习成本低，简单实用，Jedis实例是线程不安全的，多线程环境下需要基于连接池来使用
- 支持连接池
- 支持pipelining、事务、LUA Scripting、Redis Sentinel、Redis Cluster
- 不支持读写分离，需要自己实现
- 文档差（真的很差，几乎没有……）

## Redisson

- 基于Netty实现，采用非阻塞IO，性能高
- 基于redis实现了分布式的、可伸缩的Java数据结构及合，如Map、Queue、Lock、Semaphore、AtomicLong等强大功能
- 支持异步请求
- 支持连接池
- 支持pipelining、LUA Scripting、Redis Sentinel、Redis Cluster
- 不支持事务，官方建议以LUA Scripting代替事务
- 支持读写分离，支持读负载均衡，在主从复制和Redis Cluster架构下都可以使用
- 文档较丰富，有中文文档

## Lettuce

- 基于Netty实现，支持同步、异步和响应式编程方式，并且是线程安全的，支持redis的哨兵模式、集群模式和管道模式

# SpringDataRedis

## 介绍

- 提供了对不同redis客户端的整合，Lettuce（默认）和Jedis
- 提供了RedisTemplate统一API操作redis
- 支持redis的发布订阅模型
- 支持redis哨兵的redis集群
- 支持基于lettuce的响应式编程
- 支持基于JDK,String，JSON，Spring对象的数据序列化和反序列化
- 支持基于redis的JDKCollection实现

## redisTemplate

- `redisTemplate.opsForValue()`
  - 返回`ValueOperations`
  - 操作`String`类型数据
- `redisTemplate.opsForHash()`
  - 返回`HashOperations`
  - 操作`Hash`类型数据
- `redisTemplate.opsForList()`
  - 返回`ListOperations`
  - 操作`List`类型数据
- `redisTemplate.opsForSet()`
  - 返回`SetOperations`
  - 操作`Set`类型数据
- `redisTemplate.opsForZSet()`
  - 返回`ZSetOperations`
  - 操作`ZSet`类型数据

## 序列化策略

### String序列化策略

### JDK序列化策略

### 序列化方式

- defaultSerializer      默认序列化策略
- key                          普通key,非hash
- value                       普通value,非hash
- hashKey                  hash的filed
- hashValue               hash的value
- key和hashKey:   推荐使用   StringRedisSerializer: 简单的字符串序列化
- hashValue:         推荐使用   GenericJackson2JsonRedisSerializer

### 序列化类

- `GenericToStringSerializer`: 可以将任何对象泛化为字符串并序列化

- `Jackson2JsonRedisSerializer`: 跟JacksonJsonRedisSerializer实际上是一样的

- `JacksonJsonRedisSerializer`: 序列化object对象为json字符串

- `JdkSerializationRedisSerializer`: 序列化java对象（被序列化的对象必须实现Serializable接口）,无法转义成对象

  可读性差，内存占用较大

- `StringRedisSerializer`: 简单的字符串序列化
- `GenericToStringSerializer`:类似StringRedisSerializer的字符串序列化
- `GenericJackson2JsonRedisSerializer`:类似Jackson2JsonRedisSerializer，但使用时构造函数不用特定的类

